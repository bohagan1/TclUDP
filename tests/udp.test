# Commands covered:  udp_open udp_conf udp_peek
#
# This file contains a collection of tests for one or more of the Tcl
# UDP package commands.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# Copyright (c) 2003 by Pat Thoyts <patthoyts@users.sourceforge.net>
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @(#) $Id: udp.test,v 1.4 2003/03/12 00:21:17 patthoyts Exp $

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import ::tcltest::*
}

package require udp

# -------------------------------------------------------------------------

test udp-1.0 {udp_open with any port} {
    global _udp
    list [catch {
        set _udp [udp_open]
        regexp {sock\d+} $_udp } msg] $msg
} {0 1}

test udp-1.1 {udp_conf -myport} {
    global _udp
    list [catch {string is integer [udp_conf $_udp -myport]} msg] $msg
} {0 1}

test udp_1.3 {close udp socket} {
    global _udp
    list [catch {close $_udp} msg] $msg
} {0 {}}

test udp-1.4 {udp_open on assigned port} {
    list [catch {
        set port 0xf0b0
        set s [udp_open $port]
        set check [udp_conf $s -myport]
        close $s
        format 0x%04x $check
    } msg] $msg
} {0 0xf0b0}

test udp-1.5 {udp_conf -remote before seting remote details} {
    list [catch {
        set s [udp_open]
        set r [udp_conf $s -remote]
        close $s
        set r
    } msg] $msg
} {0 {}}

test udp-1.6 {udp_conf -peer before setting remote details} {
    list [catch {
        set s [udp_open]
        set r [udp_conf $s -peer]
        close $s
        set r
    } msg] $msg
} {0 {}}


test udp-2.0 {udp_conf using service name} {
    list [catch {
        set s [udp_open]
        udp_conf $s localhost ntp
        set r [udp_conf $s -remote]
        close $s
        set r} msg] $msg
} {0 {localhost 123}}

test udp-2.1 {udp_conf using service number} {
    list [catch {
        set s [udp_open]
        udp_conf $s localhost 123
        set r [udp_conf $s -remote]
        close $s
        set r} msg] $msg
} {0 {localhost 123}}

test udp-2.2 {udp_open on named port} {pcOnly} {
    list [catch {
        set port ntp
        set s [udp_open $port]
        set check [udp_conf $s -myport]
        close $s
        format 0x%04x $check
    } msg] $msg
} {0 0x007b}
 
test udp-3.0 {add multicast groups} \
    -body {
	set s [udp_open]
	fconfigure $s -mcastadd 224.1.1.1
    } -result {224.1.1.1} -cleanup {
        close $s
    }

test udp-3.1 {fconfigure -mcastgroups shows multicast groups} \
    -body {
	set s [udp_open]
	fconfigure $s -mcastadd 224.1.1.1
	fconfigure $s -mcastadd 224.1.1.2
	fconfigure $s -mcastadd 224.1.1.3
	fconfigure $s -mcastgroups
    } -result {224.1.1.1 224.1.1.2 224.1.1.3} -cleanup {
	close $s
    }

test udp-3.2 {add multicast groups with shared object} \
    -body {
	set s [udp_open]
	set maddr [fconfigure $s -mcastadd 224.1.1.1]
	set maddr [fconfigure $s -mcastadd 224.1.1.2]
	set maddr [fconfigure $s -mcastadd 224.1.1.3]
    } -result {224.1.1.1 224.1.1.2 224.1.1.3} -cleanup {
	close $s
    }

test udp-3.3 {drop multicast groups} \
    -body {
	set s [udp_open]
	set maddr [fconfigure $s -mcastadd 224.1.1.1]
	set maddr [fconfigure $s -mcastadd 224.1.1.2]
	set maddr [fconfigure $s -mcastadd 224.1.1.3]
	set maddr [fconfigure $s -mcastdrop 224.1.1.3]
	set maddr [fconfigure $s -mcastdrop 224.1.1.2]
	set maddr [fconfigure $s -mcastdrop 224.1.1.1]
    } -result {} -cleanup {
	close $s
    }

test udp-3.4 {drop multicast groups with shared object} \
    -body {
	set s [udp_open]
	set maddr [fconfigure $s -mcastadd 224.1.1.1]
	set maddr [fconfigure $s -mcastadd 224.1.1.2]
	set maddr [fconfigure $s -mcastadd 224.1.1.3]
	set maddr [fconfigure $s -mcastadd 224.1.1.4]
	set maddr [fconfigure $s -mcastadd 224.1.1.5]
	set maddr [fconfigure $s -mcastdrop 224.1.1.4]
	set maddr [fconfigure $s -mcastdrop 224.1.1.5]
    } -result {224.1.1.1 224.1.1.2 224.1.1.3} -cleanup {
	close $s
    }

test udp-3.5 {add empty group} \
    -body {
	set s [udp_open]
	set maddr [fconfigure $s -mcastadd ""]
    } -returnCodes error -match glob -result {*} -cleanup {
	close $s
    }

# Windows does not treat this as an error
test udp-3.6 {add non-multicast IP as multicast group} \
    -constraints "unix" \
    -body {
	set s [udp_open]
	set maddr [fconfigure $s -mcastadd "127.0.0.1"]
    } -returnCodes error -match glob -result {error changing multicast group*} -cleanup {
	close $s
    }

test udp-3.7 {drop multicast group that has not been joined} \
    -body {
	set s [udp_open]
	set maddr [fconfigure $s -mcastdrop "224.1.1.1"]
    } -returnCodes error -match glob -result {error changing multicast group*} -cleanup {
	close $s
    }

test udp-3.8 {multicastloop can be set to true} \
    -body {
	set s [udp_open]
	fconfigure $s -mcastloop "true"
	fconfigure $s -mcastloop
    } -result {1} -cleanup {
	close $s
    }

test udp-3.9 {multicastloop can be set to false} \
    -body {
	set s [udp_open]
	fconfigure $s -mcastloop "true"
	fconfigure $s -mcastloop "no"
	fconfigure $s -mcastloop
    } -result {0} -cleanup {
	close $s
    }

# By default, Linux will limit a socket to joining 20 multicast groups.  That
# can be increased by running this:
#        sysctl -w net.ipv4.igmp_max_memberships=<new_limit>
#  At a large number of groups (e.g. > 200), the kernel may run into memory
#  limits when trying to add additional groups.  This limit can be increased
#  with this command:
#        sysctl -w net.core.optmem_max=<new_limit>
#  Solaris and Windows seem to have no limit
test udp-3.10 {add lots of multicast groups} \
    -body {
	set s [udp_open]
	for {set m 0} {$m <= 0} {incr m} {
	    for {set n 0} {$n <= 19} {incr n} {
		set maddr [fconfigure $s -mcastadd 224.1.$m.$n]
	    }
	}
	llength [fconfigure $s -mcastgroups]
    } -result {20} -cleanup {
	close $s
    }

test udp-4.1 {fconfigure -dstip with no data} \
    -body {
	set s [udp_open]
	fconfigure $s -dstip
    } -result {{}} -cleanup {
	close $s
    }

# -------------------------------------------------------------------------
# cleanup
catch {unset _udp}
::tcltest::cleanupTests
return

# Local variables:
# mode: tcl
# indent-tabs-mode: nil
# End:
